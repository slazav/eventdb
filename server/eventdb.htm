<html>
<head>
</head>

<body>

<h3>Eventdb server</h3>

<ul>
<li><a href="#arch"><b>Архитектура</b></a>
<li><a href="#user"><b>Сервер: работа с пользователями</b></a>
<li><a href="#data"><b>Сервер: работа с данными</b></a>
<li><a href="#file"><b>Сервер: работа с файлохранилищем -- не сделано</b></a>
</ul>

<hr><a name=arch></a><h3>Архитектура</h3>

<p>suid программа-сервер, написанная на c++, которая от моего имени
выполняет разные действия. Управляется перловым cgi-скриптом. Через
аргументы ей передается название команды и ее параметры. Затем на stdin
- секретная строчка и, возможно, еще параметры (в зависимости от
конкретного действия). На stdout выдается результат в формате json.
Информация хранится в berkleydb (ключ - строка или число, значение -
json).

<p>Для работы с базой данных используется библиотека berkleydb, Для работы с json -
библиотека jansson. Используются две самодельные библиотеки:
<ul>
<li> jsonxx - C++ обертка для jansson (в интернете можно найти готовую обертку,
но мне она понравилась гораздо меньше)
<li> jsondb - C++ библиотека для базы данных с json-значениями. Самое мощное тут -
экстрактор полей, позволяющий строить индексы по разным полям внутри json'а.
</ul>

<p>Все ошибки оформлены в виде исключений, которые ловятся и возвращаются
в объекте json с полями error_type и error_message.

<p>TODO: такое надо бы, конечно, делать в виде сервера...

<!------------------------------------------------------------------->
<hr><a name=user></a><h3>Сервер: работа с пользователями</h3>

<p>Авторизация происходит только через сервис loginza.ru. Для тестовых целей
предусмотрена эмуляция (см конфигурационный файл и тестовый скрипт).
По ссылке "войти" пользователь запускает окно loginza, там выбирает сервис,
через который он будет логиниться. loginza запрашивает информацию у этого
сервиса и отдает пользователю секретный токен. Далее токен отправляется
на сервер (см. команду login) и тот запрашивает информацию у loginza.

<p>По информации, полученной от loginza, строится json-объект со
следующими полями:

<p>Объект <em>Face</em>:
<ul>
<li> <em>id</em>   -- url-идентификатор пользователя
<li> <em>name</em> -- полное имя
<li> <em>site</em> -- краткое имя сервиса: fb, lj, google и т.п.
</ul>

<p>Один пользователь на сайте может быть представлен несколькими "лицами",
то есть может заходить с нескольких сервисов.

<h4>База данных пользователей</h4>

<p>Ключ - уникальное целое число (которое потом нигде не используется)
<br>Значение -- json-объект со следующими полями:

<p>Объект <em>User</em>:
<ul>
<li> <em>id</em>    -- Идентификатор пользователя, целое положительное число
                       (jsondb помещает в это поле ключ бызы данных).
<li> <em>alias</em> -- Уникальное имя пользователя на сайте (например, "slazav").
<li> <em>level</em> -- Уровень доступа, число (-1,0,1,2,3).

<li> <em>faces</em>   -- Массив объектов типа Face, "лица" пользователя в разных соцсетях.
<li> <em>joinreq</em> -- Массив объектов типа Face, запросы на присоединение новых "лиц".

<li> <em>session</em> -- идентификатор сессии, по которому предоставляется доступ
<li> <em>stime</em>   -- время последнего логина/логаута
<li> <em>sid</em>     -- face id, которое использовалось для последнего логина.
                         (Эта информация нужна, поскольку при создании разных объектов,
                          для идентификации пользователя в них хочется хранить face id
                          -- самый "неизменный" идентификатор.)
</ul>

<p>Для базы данных строятся индексы по полям alias, faces/id, session, то есть,
пользователя можно найти по этим значениям. При построении индексов требуется
уникальность этих полей.

<p>Уровни доступа:

<ul>
<li>LEVEL_ANON=-1 -- забаненный пользователь, те же права, что у анонима,
<li>LEVEL_NORM=0  -- обычный,
<li>LEVEL_MODER=1 -- модератор,
<li>LEVEL_ADMIN=2 -- администратор,
<li>LEVEL_SUPER=3 - самый главный (единственный) пользователь.
</ul>

<p>Первый новый пользователь получает уровень LEVEL_SUPER, все остальные
-- LEVEL_NORM.

<p>Пользователь может менять уровни других пользователей, если начальное и
конечное значение меньше его собственного уровня. Таким образом,
модераторы могут забанить/разбанить обычного пользователя, а администратор
еще и назначать модераторов.

<p>alias пользователь может менять сам себе. Огранияения: 2-30 символов,
цифры, латинские буквы, '_'. Алиас не может совпадать с чужим алиасом.
При первом заходе пользователь получает автоматически созданный (на основе имени
в face или, если не выполнены условия по допустимым символам или уникальности,
user01, user02 и т.п.)



<h4>Команды для работы с пользователями</h4>

<ul>
<li><b>login (без параметров) -- войти (начать новую сессию)</b>

<p>В качестве секретной строчки передается токен loginza. По этому токену
запрашивается информация о пользователе. Если пользователя нет в
БД - он создается с уровнем LEVEL_NORM и автоматически созданным алиасом. Если
это первый пользователь в базе - его уровень выставляется в LEVEL_SUPER.
Если пользьзователь существует - обновляется соответствующее поле face
(на случай изменения имени).

<p>Для успешного выполнения нужно: правильный ответ от loginza.
<p>Возвращается: полная запись о пользователе.

<p>Во всех остальных командах в качестве секретной строчки используется
id сессии (или пустая строка для анонимного входа).


<li><b>logout (без параметров) -- выйти (удалить сессию)</b>

<p>Для успешного выполнения нужно: существующий в базе id сессии
<p>Изменение в базе данных: для пользователя удаляется сессия, обновляется stime.
<p>Возвращается: запись об анонимном пользователе (довольно бессмысленная).


<li><b>my_info (без параметров) -- получить информацию о себе</b>

<p>Возвращается: полная запись о пользователе (если дана существующая сессия)
или запись об анонимном пользователе (если id сессии пусто, или неверно, или базы
данных нет).


<li><b>set_alias &lt;new_alias&gt; -- поменять имя пользователя</b>

<p>Для успешного выполнения нужно:
<ul>
<li> существующий в базе id сессии
<li> new_alias от 2 до 30 символов, латинские буквы, цифры, "_"
<li> new_alias не совпадает с алиалом какого-либо еще пользователя
</ul>
<p>Изменение в базе данных: меняется alias пользователя.
<p>Возвращается: полная запись о пользователе.


<li><b>set_level &lt;alias2&gt; &lt;new_level&gt; -- поменять уровень другого пользователя</b>

<p>Для успешного выполнения нужно: 
<ul>
<li> существующий в базе id сессии для пользователя user1
<li> существующий пользователь user2 с именем alias2
<li> user1.level больше user2.level
<li> user1.level больше new_level
<li> new_level в диапазоне от LEVEL_ANON до LEVEL_ADMIN
</ul>
<p>Изменение в базе данных: меняется уровень пользователя user2.
<p>Возвращается: запись о пользователе user2 без информации о сессии.


<li><b>user_list (без параметров) -- получить список всех пользователей</b>

<p>Для успешного выполнения нужно:
<ul>
<li> существующий в базе id сессии
<li> уровень пользователя не меньше LEVEL_MODER
</ul>
<p>Возвращается: json-массив со всеми пользователями.
<br>Из информации удаляются поля session, stime, sid.
<br>Добавляется поле level_hints, массив уровней, которые запрашивающий
пользователь способен установить с помощью команды set_level.


<li><b>joinreq_add &lt;alias2&gt; -- отправить запрос на присоединение к пользователю</b>

<p>Для успешного выполнения нужно:
<ul>
<li> существующий в базе id сессии для пользователя user1
<li> существующий пользователь user2 с именем alias2
</ul>
<p>Изменения в базе данных: к массиву user2.joinreq добавляется user1.faces.
<p>Возвращается: пустой json-объект.


<li><b>joinreq_delete &lt;N&gt; -- удалить запрос</b>

<p>Для успешного выполнения нужно: существующий в базе id сессии.
<p>Изменения в базе данных: в массиве joinreq удаляется запись с
номером N (если такая есть). Если массив становится пустым - он тоже удаляется.
<p>Возвращается: полная запись о пользователе.

<li><b>joinreq_accept &lt;N&gt; -- принять запрос</b>

<p>Для успешного выполнения нужно:
<ul>
<li> существующий в базе id сессии для пользователя user1
<li> существующий new_id = joinreq[N].id
<li> существующий пользователь user2 с new_id.
</ul>

<p>Изменения в базе данных:
<ul>
<li> user1.level выствляется в максимальное значение из user1.level и user2.level
<li> из user2.faces удаляется запись с new_id.
<li> если массив user2.faces стал пустым, то удаляется весь пользователь user2.
<li> к user1.faces добавляется элемент user1.joinreq[N]
<li> элемент user1.joinreq[N] удаляется
<li> если массив user1.joinreq  стал пустым, то он удаляется.
</ul>
<p>Возвращается: полная запись о пользователе.

</ul>

<!------------------------------------------------------------------->
<hr><a name=data></a><h3>Сервер: работа с данными -- не сделано</h3>

<p>Сервер позволяет создавать, редактировать, удалять, искать произвольные
json-объекты в различных базах данных.

<p>Каждой база состоит из двух частей: основной и архивной. Актуальная
версия объекта хранится в основной базе, все старые версии - в архивной.
Индексы для поиска объектов строятся только по основной базе.

<p>Название базы данных должно состоять из латинских букв, цифр и знака "_" и
содержать от 2 до 30 символов (также, как alias пользователя).

<p>При удалении объектов они помечаются специальным полем del, но остаются
в основной базе.

<p>В каждом объекте сервер заботится о полях (заполняет их и следит,
чтобы туда не могла попасть информация от пользователя):
<ul>
<li> prev - ссылка на предыдущую версию в архивной базе данных.
<li> ctime, cuser - время первого создания объекта, id пользователя
<li> mtime, muser - время последнего изменения объекта, id пользователя
<li> date_key, coord_key -- ключи для поиска диапазона дат и координат
</ul>
<p> По полям ctime, cuser, mtime, muser, date_key, coord_key строятся индексы.

<p>Кроме того, некоторые поля имеют специальное значение и фиксированный
формат - по ним строятся другие поля или индексы, производится поиск:
<ul>
<li> id - при редактировании существующего объекта должен содержать его id.
     при создании нового объекта может быть пустым или содержать -1
<li> del - при удалении объекта должен содержать 1, иначе может отсутствовать или содержать 0.
<li> date1, date2 - Диапазон дат. По ним строится поле date_key и производится поиск.
<li> lon1, lon2, lat1, lat2 - Диапазон координат. По ним строится поле coord_key и производится поиск.
<li> keys - Массив ключей объекта (строки) - строится индекс.  Я предполагаю использовать ключи вида
            &lt;тип&gt;:&lt;значение&gt; для хранения типа объекта и всяких списков, по которым можно искать.
</ul>

<h4>Команды для работы с данными</h4>

<ul>
<li><b>write  &lt;bd&gt; -- записать объект</b>

<p>С stdin читается сессия и json-объект, из параметров берется
имя базы данных. Название базы проверяется проверяется.

<p>Если база не существует и уровень пользователя ADMIN или выше - то
база создается.

<p>JSON-объект может содержать поле id, в этом случае проверяется, что
такой объект существует и он обновляется. Если id отсутствует или равно
-1, то создается новый объект. Также может быть целое ненулевое поле del
-- в этом случае объект отмечается как удаленный и в поиске не выдается.

<p>При обновлении объекта проверяются права: объект может обновить только
его создатель или пользователь с уровнем MODER и выше.

<p>Старый объект уходит в архив, для нового объекта обновляются поля
mtime/muser, ctime/cuser, prev.

<p>TODO: Проверяются индексные поля, создаются ключи для поиска по диапазонам.


<li><b>read &lt;bd&gt; &lt;id&gt; -- информация об объекте</b>

<li><b>read_arc &lt;bd&gt; &lt;id&gt; -- информация об объекте из архива</b>

<li><b>del    &lt;bd&gt; &lt;id&gt; -- удалить объект</b>
<li><b>search &lt;bd&gt; -- поиск объектов</b>

</ul>

<!------------------------------------------------------------------->
<hr><a name=file></a><h3>Сервер: работа с файлохранилищем -- не сделано</h3>

<p>TODO?: Основной базе данных должно быть все равно, где лежит файл -
в хранилище или по внешнему url'у. Соответственно, к файлу можно
не привязывать информацию.


</body>
</html>
